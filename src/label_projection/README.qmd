---
format: gfm
info:
  v1_url: openproblems/tasks/label_projection/README.md
  v1_commit: 817ea64a526c7251f74c9a7a6dba98e8602b94a8
toc: true
---

```{r setup, include=FALSE}
library(tidyverse)
library(rlang)

strip_margin <- function(text, symbol = "\\|") {
  str_replace_all(text, paste0("(\n?)[ \t]*", symbol), "\\1") 
}

dir <- "src/label_projection"
dir <- "."
```

# Label Projection

## The task

A major challenge for integrating single cell datasets is creating matching cell type annotations for each cell. One of the most common strategies for annotating cell types is referred to as ["cluster-then-annotate"](https://www.nature.com/articles/s41576-018-0088-9) whereby cells are aggregated into clusters based on feature similarity and then manually characterized based on differential gene expression or previously identified marker genes. Recently, methods have emerged to build on this strategy and annotate cells using [known marker genes](https://www.nature.com/articles/s41592-019-0535-3). However, these strategies pose a difficulty for integrating atlas-scale datasets as the particular annotations may not match.

To ensure that the cell type labels in newly generated datasets match existing reference datasets, some methods align cells to a previously annotated [reference dataset](https://academic.oup.com/bioinformatics/article/35/22/4688/54802990) and then _project_ labels from the reference to the new dataset.

Here, we compare methods for annotation based on a reference dataset. The datasets consist of two or more samples of single cell profiles that have been manually annotated with matching labels. These datasets are then split into training and test batches, and the task of each method is to train a cell type classifer on the training set and project those labels onto the test set.



## Methods

Methods for assigning labels from a reference dataset to a new dataset.

```{r methods, echo=FALSE,warning=FALSE,error=FALSE,output="asis"}
method_yamls <- list.files(paste0(dir, "/methods"), pattern = "config.vsh.yaml", full.names = TRUE, recursive = TRUE)

method_info <- map_df(method_yamls, function(method_yaml) {
  out <- system(paste0("viash config view ", method_yaml), intern = TRUE, ignore.stderr = TRUE)
  config <- yaml::yaml.load(out)
  if (length(config$functionality$status) > 0 && config$functionality$status == "disabled") return(NULL)
  info <- as_tibble(config$functionality$info)
  info$comp_yaml <- method_yaml
  info$name <- config$functionality$name
  info$namespace <- config$functionality$namespace
  info$description <- config$functionality$description
  info
})

method_info_view <- 
  method_info %>%
    transmute(
      Name = paste0("[", label, "](", comp_yaml, ")"),
      Description = description,
      DOI = ifelse(!is.na(paper_doi), paste0("[link](https://doi.org/", paper_doi, ")"), ""),
      URL = ifelse(!is.na(code_url), paste0("[link](", code_url, ")"), "")
    )

cat(paste(knitr::kable(method_info_view, format = 'pipe'), collapse = "\n"))
```


## Metrics

Metrics for label projection aim to characterize how well each classifier correctly assigns cell type labels to cells in the test set.

```{r metrics, echo=FALSE,warning=FALSE,error=FALSE,output="asis"}
metric_yamls <- list.files(paste0(dir, "/metrics"), pattern = "config.vsh.yaml", full.names = TRUE, recursive = TRUE)

metric_info <- map_df(metric_yamls, function(metric_yaml) {
  out <- system(paste0("viash config view ", metric_yaml), intern = TRUE, ignore.stderr = TRUE)
  config <- yaml::yaml.load(out)
  metric_info <- as_tibble(map_df(config$functionality$info$metrics, as.data.frame))
  metric_info$comp_yaml <- metric_yaml
  metric_info$comp_name <- config$functionality$name
  metric_info$comp_namespace <- config$functionality$namespace
  metric_info
})

metric_info_view <- 
  metric_info %>%
    transmute(
      # Name = paste0("[", label, "](", comp_yaml, ")"),
      # Description = paste0(description, " Range: [", min, ", ", max, "]. ", ifelse(maximise, "Higher is better.", "Lower is better.")),
      str = paste0("* **[", label, "](", comp_yaml, ")**: ", description, " Range: [", min, ", ", max, "]. ", ifelse(maximise, "Higher is better.", "Lower is better."))
    )

cat(paste(metric_info_view$str, collapse = '\n'))
```


## Pipeline topology

```{r data, include=FALSE}
comp_yamls <- list.files(paste0(dir, "/api"), pattern = "comp_", full.names = TRUE)
file_yamls <- list.files(paste0(dir, "/api"), pattern = "anndata_", full.names = TRUE)

comp_file <- map_df(comp_yamls, function(yaml_file) {
  conf <- yaml::read_yaml(yaml_file)

  map_df(conf$functionality$arguments, function(arg) {
    tibble(
      comp_name = basename(yaml_file) %>% gsub("\\.yaml", "", .),
      arg_name = str_replace_all(arg$name, "^-*", ""),
      direction = arg$direction %||% "input",
      file_name = basename(arg$`__inherits__`) %>% gsub("\\.yaml", "", .)
    )
  })
})

comp_info <- map_df(comp_yamls, function(yaml_file) {
  conf <- yaml::read_yaml(yaml_file)

  tibble(
    name = basename(yaml_file) %>% gsub("\\.yaml", "", .),
    label = name %>% gsub("comp_", "", .) %>% gsub("_", " ", .)
  )
})

file_info <- map_df(file_yamls, function(yaml_file) {
  arg <- yaml::read_yaml(yaml_file)
  
  tibble(
    name = basename(yaml_file) %>% gsub("\\.yaml", "", .),
    description = arg$description,
    short_description = arg$info$short_description,
    example = arg$example,
    label = name %>% gsub("anndata_", "", .) %>% gsub("_", " ", .)
  )
})

file_slot <- map_df(file_yamls, function(yaml_file) {
  arg <- yaml::read_yaml(yaml_file)

  map2_df(names(arg$info$slots), arg$info$slots, function(group_name, slot) {
    df <- map_df(slot, as.data.frame)
    df$struct <- group_name
    df$file_name = basename(yaml_file) %>% gsub("\\.yaml", "", .)
    as_tibble(df)
  })
}) %>% 
  mutate(multiple = multiple %|% FALSE)
```

```{r flow, echo=FALSE,warning=FALSE,error=FALSE}
nodes <- bind_rows(
  file_info %>%
    transmute(id = name, label = paste0(label, ".h5ad"), is_comp = FALSE),
  comp_info %>%
    transmute(id = name, label, is_comp = TRUE)
) %>%
  mutate(str = paste0(
    "  ",
    id, 
    ifelse(is_comp, "[/", "("), 
    label,
    ifelse(is_comp, "/]", ")")
  ))
edges <- bind_rows(
  comp_file %>%
    filter(direction == "input") %>%
    transmute(
      from = file_name,
      to = comp_name,
      arrow = "---"
    ),
  comp_file %>%
    filter(direction == "output") %>%
    transmute(
      from = comp_name, 
      to = file_name, 
      arrow = "-->"
    )
) %>%
  mutate(str = paste0("  ", from, arrow, to))

# note: use ```{mermaid} instead of ```mermaid when rendering to html
out_str <- strip_margin(glue::glue("
  §```mermaid
  §%%| column: screen-inset-shaded
  §flowchart LR
  §{paste(nodes$str, collapse = '\n')}
  §{paste(edges$str, collapse = '\n')}
  §```
  §"), symbol = "§")
knitr::asis_output(out_str)
```

## File format API

```{r file_api, echo=FALSE,warning=FALSE,error=FALSE,output="asis"}
for (file_name in file_info$name) {
  arg_info <- file_info %>% filter(name == file_name)
  sub_out <- file_slot %>% 
    filter(file_name == !!file_name) %>% 
    select(struct, name, type, description)
  used_in <- comp_file %>%
    filter(file_name == !!file_name) %>%
    left_join(comp_info %>% select(comp_name = name, comp_label = label), by = "comp_name") %>%
    mutate(str = paste0("* [", comp_label, "](#", comp_label, "): ", arg_name, " (as ", direction, ")")) %>%
    pull(str)
  
  out_str <- strip_margin(glue::glue("
    §### `{arg_info$label}.h5ad`: {arg_info$short_description} {{#file-{arg_info$label}}}
    §
    §{arg_info$description}
    §
    §Used in:
    §
    §{paste(used_in, collapse = '\n')}
    §
    §Slots:
    §
    §{paste(knitr::kable(sub_out, format = 'pipe'), collapse = '\n')}
    §"), symbol = "§")
  cat(out_str)
}
```



## Component API

```{r comp_api, echo=FALSE,warning=FALSE,error=FALSE,output="asis"}
# todo: add description
# todo: add required info fields
for (comp_name in comp_info$name) {
  comp <- comp_info %>% filter(name == comp_name)
  sub_out <- comp_file %>% 
    filter(comp_name == !!comp_name) %>%
    left_join(file_info %>% select(file_name = name, file_desc = description, file_sdesc = short_description, file_label = label), by = "file_name") %>%
    transmute(
      Name = paste0("`--", arg_name, "`"),
      `File format` = paste0("[", file_label, ".h5ad](#file-", file_label, ")"),
      Direction = direction,
      Description = file_sdesc
    )
  
  out_str <- strip_margin(glue::glue("
    §### `{comp$label}`
    §
    §{ifelse(\"description\" %in% names(comp), comp$description, \"\")}
    §
    §Arguments:
    §
    §{paste(knitr::kable(sub_out, format = 'pipe'), collapse = '\n')}
    §"), symbol = "§")
  cat(out_str)
}
```