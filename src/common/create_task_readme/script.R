library(rlang, quietly = TRUE, warn.conflicts = FALSE)
library(purrr, quietly = TRUE, warn.conflicts = FALSE)
library(dplyr, quietly = TRUE, warn.conflicts = FALSE)
library(yaml, quietly = TRUE, warn.conflicts = FALSE)
library(openproblems)

## VIASH START
par <- list(
  "task" = "batch_integration",
  "task_dir" = "src/tasks/batch_integration",
  "output" = "src/tasks/batch_integration/README.md",
  "viash_yaml" = "_viash.yaml",
  "github_url" = "https://github.com/openproblems-bio/openproblems-v2/tree/main/"
)
meta <- list(
  "resources_dir" = "src/common/helper_functions",
  "temp_dir" = "temp/"
)
## VIASH END

if (is.null(par$task) && is.null(par$task_dir)) {
  stop("Either 'task' or 'task_dir' must be provided")
}
if (is.null(par$viash_yaml)) {
  stop("Argument 'viash_yaml' must be provided")
}
if (is.null(par$output)) {
  stop("Argument 'output' must be provided")
}

# import helper function
source(paste0(meta["resources_dir"], "/read_api_files.R"))

cat("Read task info\n")
task_api <- read_task_api(par[["task_dir"]])
viash_info <- yaml.load_file(par[["viash_yaml"]])

# determine ordering
root <- .task_graph_get_root(task_api)

r_graph <- render_task_graph(task_api, root)

cat("Render API details\n")
order <- names(igraph::bfs(task_api$task_graph, root)$order)
r_details <- map_chr(
  order,
  function(file_name) {
    if (file_name %in% names(task_api$comp_specs)) {
      render_component(task_api$comp_specs[[file_name]])
    } else {
      render_file(task_api$file_specs[[file_name]])
    }
  }
)

cat("Render authors\n")
authors_str <-
  if (nrow(task_api$authors) > 0) {
    paste0(
      "\n## Authors & contributors\n\n",
      task_api$authors %>% knitr::kable() %>% paste(collapse = "\n"),
      "\n"
    )
  } else {
    ""
  }

readme_base <- openproblems::strip_margin(glue::glue("
  §## Installation
  §
  §You need to have Docker, Java, and Viash installed. Follow
  §[these instructions](https://openproblems.bio/documentation/fundamentals/requirements)
  §to install the required dependencies.
  §
  §## Add a method
  §
  §To add a method to the repository, follow the instructions in the `scripts/add_a_method.sh` script.
  §
  §## Frequently used commands
  §
  §To get started, you can run the following commands:
  §
  §```bash
  §git clone git@github.com:openproblems-bio/{viash_info$name}.git
  §
  §cd {viash_info$name}
  §
  §# initialise submodule
  §scripts/init_submodule.sh
  §
  §# download resources
  §scripts/download_resources.sh
  §```
  §
  §To run the benchmark, you first need to build the components. Afterwards, you can run the benchmark:
  §
  §```bash
  §viash ns build --parallel --setup cachedbuild
  §
  §scripts/run_benchmark.sh
  §```
  §
  §After adding a component, it is recommended to run the tests to ensure that the component is working correctly:
  §
  §```bash
  §viash ns test --parallel
  §```
  §
  §Optionally, you can provide the `--query` argument to test only a subset of components:
  §
  §```bash
  §viash ns test --parallel --query 'component_name'
  §```
"), symbol = "§")

readme_str <-
  if (is.null(task_api$task_info$readme) || is.na(task_api$task_info$readme)) {
    paste0(
      "\n## README\n\n",
      readme_base,
      "\n"
    )
  } else {
    paste0(
      "\n## README\n\n",
      task_api$task_info$readme,
      "\n"
    )
  }

# get relevant taks info



cat("Generate qmd content\n")
relative_path <- par[["task_dir"]] %>%
  gsub(paste0(dirname(par[["viash_yaml"]]), "/*"), "", .) %>%
  gsub("/*$", "", .)
source_url <- paste0(viash_info$links$repository, "/", relative_path)
qmd_content <- openproblems::strip_margin(glue::glue("
  §---
  §title: \"{task_api$task_info$label}\"
  §format: gfm
  §---
  §
  §<!--
  §This file is automatically generated from the tasks's api/*.yaml files.
  §Do not edit this file directly.
  §-->
  §
  §{task_api$task_info$summary}
  §
  §Path to source: [`{relative_path}`]({source_url})
  §
  §{readme_str}
  §
  §## Motivation
  §
  §{task_api$task_info$motivation}
  §
  §## Description
  §
  §{task_api$task_info$description}
  §{authors_str}
  §## API
  §
  §{r_graph}
  §
  §{paste(r_details, collapse = '\n\n')}
  §
  §"), symbol = "§")

cat("Write README.qmd to file\n")
qmd_file <- tempfile(
  pattern = "README_",
  fileext = ".qmd",
  tmpdir = meta$temp_dir
)

if (!dir.exists(meta$temp_dir)) {
  dir.create(meta$temp_dir, recursive = TRUE)
}
writeLines(qmd_content, qmd_file)

cat("Render README.qmd to README.md\n")
out <- processx::run(
  command = "quarto",
  args = c("render", qmd_file, "--output", "-"),
  echo = TRUE
)

writeLines(out$stdout, par$output)
